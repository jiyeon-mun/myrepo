-- JOIN : 2개 이상의 테이블에서 데이터를 조회하기 위해 사용하는 구문
--        집합 구문과는 다르게 쿼리 결과에 대한 무조건적인 집합(쿼리)셋을 구하는 것이 아닌
--        쿼리 결과에 대한 결합 조건이 있다.
--        집합 구문은 행(로우) 데이터에 대한 추가가 이루어 지지만. JOIN 은 열(컬럼) 데이터에 대한
--        추가가 이루어 진다.

-- Oracle 전용 구문; JOIN 역할; WHERE 문 이용
SELECT *
  FROM EMPLOYEES, DEPARTMENTS
 WHERE EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID;

-- JOIN 형식
-- ON()은 연결에 사용하는 컬럼명이 다른 경우에 사용하나, 같은 경우에도 아래와 같은 형식으로 사용됨.
SELECT *
  FROM EMPLOYEES JOIN DEPARTMENTS
    ON (EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID);
-- 연결에 사용하는 컬럼명이 같은 경우 USING() 사용함.
-- 공통되는 컬럼과 그 데이터값이 첫번째 열로 온다.
SELECT *
  FROM EMPLOYEES JOIN DEPARTMENTS USING(DEPARTMENT_ID);


-- 조인을 수행하는 테이블의 컬럼이 동일한 이름을 사용하는 경우 테이블명.컬럼명 으로 구분시킨다.
SELECT EMPLOYEES.EMPLOYEE_ID AS 사원코드
     , CONCAT(EMPLOYEES.FIRST_NAME, ' ' || EMPLOYEES.LAST_NAME) AS 사원명
     , EMPLOYEES.DEPARTMENT_ID AS 부서코드
     , DEPARTMENTS.DEPARTMENT_NAME AS 부서명
  FROM EMPLOYEES JOIN DEPARTMENTS
    ON (EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID);

-- 테이블명에 별칭을 부여할 수 있음.
SELECT A.EMPLOYEE_ID AS 사원코드
     , CONCAT(A.FIRST_NAME, ' ' || A.LAST_NAME) AS 사원명
     , A.DEPARTMENT_ID AS 부서코드
     , B.DEPARTMENT_NAME AS 부서명
  FROM EMPLOYEES A JOIN DEPARTMENTS B
    ON (A.DEPARTMENT_ID = B.DEPARTMENT_ID);

-- 조인 조건의 컬럼명이 동일한 경우 USING 을 사용하여 결합시킬 수 있다.
SELECT A.EMPLOYEE_ID AS 사원코드
     , CONCAT(A.FIRST_NAME, ' ' || A.LAST_NAME) AS 사원명
     , DEPARTMENT_ID AS 부서코드
     , B.DEPARTMENT_NAME AS 부서명
  FROM EMPLOYEES A JOIN DEPARTMENTS B
 USING (DEPARTMENT_ID);


-- 2개 이상의 테이블에 대한 조인
SELECT A.EMPLOYEE_ID AS 사원코드
     , CONCAT(A.FIRST_NAME, ' ' || A.LAST_NAME) AS 사원명
     , DEPARTMENT_ID AS 부서코드
     , B.DEPARTMENT_NAME AS 부서명
     , JOB_ID AS 직업코드
     , C.JOB_TITLE AS 직업명
  FROM EMPLOYEES A JOIN DEPARTMENTS B
 USING (DEPARTMENT_ID)
  JOIN JOBS C
 USING (JOB_ID);


-- 아래의 테이블의 DEPARTMENT_NO, COACH_PROFESSOR_NO 를 활용하여 학과명, 교수명 컬럼이
-- 조회될 수 있도록 JOIN 을 사용
SELECT A.STUDENT_NO
     , A.STUDENT_NAME
     , A.DEPARTMENT_NO
     , B.DEPARTMENT_NAME
     , A.COACH_PROFESSOR_NO
     , C.PROFESSOR_NAME
  FROM TB_STUDENT A JOIN TB_DEPARTMENT B
    ON A.DEPARTMENT_NO = B.DEPARTMENT_NO
  JOIN TB_PROFESSOR C
    ON A.COACH_PROFESSOR_NO = C.PROFESSOR_NO;


-- OUTER JOIN : 일반 JOIN 과는 다르게 결합 조건에 부합하는 데이터가 없어도 조회 결과로 나올 수
--              있게 한다. 왼쪽 테이블을 기준으로 조회결과가 나오게 할때에는 LEFT OUTER JOIN
--              오른쪽 테이블을 기준으로 조회결과가 나오게 할떄에는 RIGHT OUTER JOIN
SELECT EMPLOYEE_ID
     , FIRST_NAME
     , LAST_NAME
     , DEPARTMENT_ID
  FROM EMPLOYEES WHERE EMPLOYEE_ID BETWEEN 175 AND 180;

SELECT A.EMPLOYEE_ID
     , A.FIRST_NAME
     , A.LAST_NAME
     , A.DEPARTMENT_ID
     , B.DEPARTMENT_NAME
  FROM EMPLOYEES A JOIN DEPARTMENTS B
    ON A.DEPARTMENT_ID = B.DEPARTMENT_ID
 WHERE A.EMPLOYEE_ID BETWEEN 175 AND 180;
-- EMPLOYEE_ID 가 WHERE 조건은 만족하나 행에 NULL 값 데이터를 갖는 경우 해당 행은 JOIN 하지 않음. 

SELECT A.EMPLOYEE_ID
     , A.FIRST_NAME
     , A.LAST_NAME
     , A.DEPARTMENT_ID
     , B.DEPARTMENT_NAME
  FROM EMPLOYEES A LEFT OUTER JOIN DEPARTMENTS B
    ON A.DEPARTMENT_ID = B.DEPARTMENT_ID
 WHERE A.EMPLOYEE_ID BETWEEN 175 AND 180;
-- WHERE 조건은 만족하는 EMPLOYEE_ID 의 행 데이터값들 모두 출력(NULL 값도)


WITH L_TB AS (
    SELECT 1 AS ID, '가' AS NAME FROM DUAL
    UNION ALL
    SELECT 2 AS ID, '나' AS NAME FROM DUAL
    UNION ALL
    SELECT 3 AS ID, '다' AS NAME FROM DUAL
), R_TB AS (
    SELECT 1 AS ID, '라' AS NAME FROM DUAL
    UNION ALL
    SELECT 2 AS ID, '마' AS NAME FROM DUAL
    UNION ALL
    SELECT 4 AS ID, '바' AS NAME FROM DUAL
)
SELECT *
  FROM L_TB A CROSS JOIN R_TB B;
    -- ON A.ID = B.ID;
-- CROSS JOIN : 카테시안 곱으로
-- 검색되는 데이터 수는 '행의 컬럼 수 * 또 다른 행의 컬럼 수'

-- NON_EQU JOIN : 일정 범위에 해당하는 열을 기준으로 조인을 하는 형식
SELECT A.EMPLOYEE_ID
     , A.FIRST_NAME
     , A.LAST_NAME
     , A.SALARY
     , B.JOB_ID
     , B.JOB_TITLE
  FROM EMPLOYEES A JOIN JOBS B
    ON A.SALARY BETWEEN B.MIN_SALARY AND B.MAX_SALARY
 ORDER BY 1;

-- SELF JOIN : 서로 다른 테이블간에 조인을 하는 방식이 아닌 동일한 테이블을 이용하여 조인을
--             하는 형식
SELECT A.EMPLOYEE_ID AS 사번
     , A.FIRST_NAME || ' ' || A.LAST_NAME AS 사원명
     , B.EMPLOYEE_ID AS 관리자사번
     , B.FIRST_NAME || ' ' || B.LAST_NAME AS 관리자명
  FROM EMPLOYEES A JOIN EMPLOYEES B
    ON A.MANAGER_ID = B.EMPLOYEE_ID
 ORDER BY 1;

SELECT * FROM JOBS;
SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, MANAGER_ID FROM EMPLOYEES;
SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME FROM EMPLOYEES;



SELECT * FROM TB_CLASS;
SELECT * FROM TB_CLASS WHERE PREATTENDING_CLASS_NO IS NOT NULL;
SELECT * FROM TB_STUDENT;
SELECT * FROM TB_PROFESSOR;
SELECT * FROM TB_CLASS_PROFESSOR;
SELECT * FROM TB_GRADE;

-- 교수별 담당 과목수가 얼마나 되는지 교수의 이름과 같이 조회하시오.
SELECT A.PROFESSOR_NO AS 교수코드
     , B.PROFESSOR_NAME AS 교수명
     , COUNT(A.CLASS_NO) AS 총과목수
  FROM TB_CLASS_PROFESSOR A JOIN TB_PROFESSOR B
    ON A.PROFESSOR_NO = B.PROFESSOR_NO
 GROUP BY A.PROFESSOR_NO, B.PROFESSOR_NAME
 ORDER BY 총과목수 DESC;

WITH TMP1 AS (
SELECT PROFESSOR_NO
     , COUNT(CLASS_NO) AS "교수별 담당 과목수"
  FROM TB_CLASS_PROFESSOR
 GROUP BY PROFESSOR_NO
)
SELECT B.PROFESSOR_NAME AS "교수명"
     , B. PROFESSOR_NO AS 교수코드
     , A."교수별 담당 과목수"
  FROM TMP1 A JOIN TB_PROFESSOR B
    ON A.PROFESSOR_NO = B.PROFESSOR_NO
 ORDER BY A."교수별 담당 과목수" DESC;

-- 학과별 배정된 교수의 인원이 얼마나 되는지 해당 학과명과 같이 조회하시오.
SELECT A.DEPARTMENT_NO AS 학과코드
     , A.DEPARTMENT_NAME AS 학과명
     , COUNT(B.PROFESSOR_NO) AS 교수인원
  FROM TB_DEPARTMENT A JOIN TB_PROFESSOR B
    ON A.DEPARTMENT_NO = B.DEPARTMENT_NO
 GROUP BY A.DEPARTMENT_NO, A.DEPARTMENT_NAME
 ORDER BY 교수인원 DESC;

-- 모든 학생들의 학점을 출력하시오.(단, 코드가 아닌 식별가능한 이름으로 출력)
SELECT A.STUDENT_NO AS 학생코드
     , A.STUDENT_NAME AS 학생명
     , B.POINT AS 학점
     , C.CLASS_NAME
  FROM TB_STUDENT A JOIN TB_GRADE B
    ON A.STUDENT_NO = B.STUDENT_NO
  JOIN TB_CLASS C
    ON B.CLASS_NO = C.CLASS_NO
 ORDER BY 학생명 DESC;

WITH TMP3 AS(
SELECT STUDENT_NO AS "학생번호"
     , SUM(POINT) AS "총학점"
  FROM TB_GRADE
  GROUP BY STUDENT_NO
)
SELECT A.STUDENT_NAME AS 학생명
     , A.STUDENT_NO AS 학생코드
     , B."총학점"
  FROM TB_STUDENT A JOIN TMP3 B
    ON A.STUDENT_NO = B."학생번호"
 ORDER BY 학생명 DESC;